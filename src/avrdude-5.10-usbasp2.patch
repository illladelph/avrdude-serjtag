diff -ru avrdude-5.10-org/avrdude.conf.in avrdude-5.10/avrdude.conf.in
--- avrdude-5.10-org/avrdude.conf.in	2010-12-21 08:20:08.000000000 +0900
+++ avrdude-5.10/avrdude.conf.in	2010-12-21 08:17:53.000000000 +0900
@@ -491,6 +491,12 @@
 ;
 
 programmer
+  id    = "usbasp2";
+  desc  = "USBasp2, ";
+  type  = usbasp;
+;
+
+programmer
   id    = "usbtiny";
   desc  = "USBtiny simple USB programmer, http://www.ladyada.net/make/usbtinyisp/";
   type  = usbtiny;
diff -ru avrdude-5.10-org/usbasp.c avrdude-5.10/usbasp.c
--- avrdude-5.10-org/usbasp.c	2010-12-21 08:20:08.000000000 +0900
+++ avrdude-5.10/usbasp.c	2011-01-04 09:45:10.000000000 +0900
@@ -39,6 +39,14 @@
 #include "pgm.h"
 #include "usbasp.h"
 
+static int prot_ver = 0;
+static int prot_type = 0;
+
+#define is_pditpi()  ((prot_type==USBASP_V2_TPI)||(prot_type ==USBASP_V2_PDI))
+#define is_pdi()  (prot_type ==USBASP_V2_PDI)
+#define is_tpi()  (prot_type==USBASP_V2_TPI))
+#define XXX // temporary debugging 
+
 #ifdef HAVE_LIBUSB
 #include <usb.h>
 
@@ -109,6 +117,11 @@
 int                 errorCode = USB_ERROR_NOTFOUND;
 static int          didUsbInit = 0;
 
+#ifdef XXX
+{
+  fprintf(stderr, "USBASP: vendor %s prod %s\n",vendorName, productName);
+}
+#endif
     if(!didUsbInit){
         didUsbInit = 1;
         usb_init();
@@ -281,12 +294,44 @@
   unsigned char temp[4];
   memset(temp, 0, sizeof(temp));
 
+  /* USBasp v2 */
+  if (!strncmp("USBasp2 (TPI)", pgm->desc, 13)) {
+	prot_ver = USBASP_PROT_V2;
+	prot_type = USBASP_V2_TPI;
+  } else if (!strncmp("USBasp2 (PDI)", pgm->desc, 13)) {
+	prot_ver = USBASP_PROT_V2;
+	prot_type = USBASP_V2_PDI;
+  } else if (!strncmp("USBasp2", pgm->desc, 7)) {
+	prot_ver = USBASP_PROT_V2;
+	prot_type = USBASP_V2_ISP2;
+        if (p->flags & AVRPART_HAS_TPI) {
+	   prot_type = USBASP_V2_TPI; // select TPI
+        } else if (p->flags & AVRPART_HAS_PDI) {
+	   prot_type = USBASP_V2_PDI; // select PDI
+        }
+  } else if (p->flags & AVRPART_HAS_TPI) {
+	prot_ver = USBASP_PROT_V2; // USBASP v2 protocol
+	prot_type = USBASP_V2_TPI; // select TPI
+  } else if (p->flags & AVRPART_HAS_PDI) {
+	prot_ver = USBASP_PROT_V2; // USBASP v2 protocol
+	prot_type = USBASP_V2_PDI; // select PDI
+  }
+  temp[1] = prot_ver;
+  temp[0] = prot_type;
+#ifdef XXX
+  fprintf(stderr, "USBASP: ver %d type %d\n",prot_ver, prot_type);
+#endif
+
   /* set sck period */
   pgm->set_sck_period(pgm, pgm->bitclock);
 
   /* connect to target device */
   usbasp_transmit(pgm, 1, USBASP_FUNC_CONNECT, temp, temp, sizeof(temp));
-
+#ifdef XXX
+if (is_pdi()) {
+  fprintf(stderr, "USBASP_FUNC_CONNECT:\n");
+}
+#endif
   /* wait, so device is ready to receive commands */
   usleep(100000);
 
@@ -329,6 +374,113 @@
 }
 
 
+static int usbasp_set_longaddr(PROGRAMMER * pgm, AVRPART * p, unsigned long addr)
+{
+  unsigned char cmd[4];
+  unsigned char temp[4];
+
+  memset(temp, 0, sizeof(temp));
+  cmd[0] = addr & 0xFF;
+  cmd[1] = addr >> 8;
+  cmd[2] = addr >> 16;
+  cmd[3] = addr >> 24;
+
+  usbasp_transmit(pgm, 1, USBASP_FUNC_SETLONGADDRESS, cmd, temp, sizeof(temp));
+#if 0 //def XXX
+if (is_pdi()) {
+  fprintf(stderr, "SET_LONGADDR: %04x\n",addr);
+  fflush(stderr);
+}
+#endif
+  return 0;
+}
+
+static int usbasp_chk_busy(PROGRAMMER * pgm, AVRPART * p)
+{
+  unsigned char cmd[4];
+  unsigned char res[4];
+
+  memset(res, 0, sizeof(res));
+  cmd[0] = ISPCMD_CHK_BUSY;
+  cmd[1] = 0;
+  cmd[2] = 0;
+  cmd[3] = 0;
+
+  pgm->cmd(pgm, cmd, res);
+
+  return res[3];
+}
+
+static int usbasp_read_cs(PROGRAMMER * pgm, AVRPART * p, unsigned long addr)
+{
+  unsigned char cmd[4];
+  unsigned char res[4];
+
+  memset(res, 0, sizeof(res));
+  cmd[0] = ISPCMD_READ_EEPROM;
+  cmd[1] = (addr >> 8);
+  cmd[2] = addr;
+  cmd[3] = 0;
+
+  pgm->cmd(pgm, cmd, res);
+
+  return ((int)res[2] << 8) | res[3];
+}
+
+static int usbasp_write_cs(PROGRAMMER * pgm, AVRPART * p, unsigned long addr, unsigned char val)
+{
+  unsigned char cmd[4];
+  unsigned char res[4];
+
+  memset(res, 0, sizeof(res));
+  cmd[0] = ISPCMD_WRITE_EEPROM;
+  cmd[1] = (addr >> 8);
+  cmd[2] = addr;
+  cmd[3] = val;
+
+  pgm->cmd(pgm, cmd, res);
+
+  return 0;
+}
+
+static int usbasp_pdi_select(PROGRAMMER * pgm, AVRPART * p, char space)
+{
+  unsigned char cmd[4];
+  unsigned char res[4];
+
+  memset(res, 0, sizeof(res));
+  cmd[0] = ISPCMD_ISP_CONF;
+  cmd[1] = ISPCONF_SET_SPACE;
+  cmd[2] = 0;
+  cmd[3] = space;
+
+  pgm->cmd(pgm, cmd, res);
+#if 0 //def XXX
+if (is_pdi()) {
+  fprintf(stderr, "SET_SPACE: %d = %02x\n",space, res[3]);
+  fflush(stderr);
+}
+#endif
+  return 0;
+}
+
+#if 0
+static int usbasp_pdi_reset(PROGRAMMER * pgm, int off)
+{
+  unsigned char cmd[4];
+  unsigned char res[4];
+  memset(res, 0, sizeof(res));
+
+  cmd[0] = ISPCMD_ISP_CONF;
+  cmd[1] = ISPCONF_RESET;
+  cmd[2] = 0;
+  cmd[3] = (off)? 0x00: 0x59;
+
+  pgm->cmd(pgm, cmd, res);
+  return 0;
+}
+#endif
+
 static int usbasp_program_enable(PROGRAMMER * pgm, AVRPART * p)
 {
   unsigned char res[4];
@@ -338,6 +490,12 @@
 
   cmd[0] = 0;
 
+#ifdef XXX
+if (is_pdi()) {
+  fprintf(stderr, "USBASP_FUNC_ENABLEPROG:");
+  fflush(stderr);
+}
+#endif
   int nbytes =
     usbasp_transmit(pgm, 1, USBASP_FUNC_ENABLEPROG, cmd, res, sizeof(res));
 
@@ -350,13 +508,13 @@
   return 0;
 }
 
-
 static int usbasp_chip_erase(PROGRAMMER * pgm, AVRPART * p)
 {
   unsigned char cmd[4];
   unsigned char res[4];
 
-  if (p->op[AVR_OP_CHIP_ERASE] == NULL) {
+  if (!is_pditpi() && (p->op[AVR_OP_CHIP_ERASE] == NULL)) {
+
     fprintf(stderr, "chip erase instruction not defined for part \"%s\"\n",
             p->desc);
     return -1;
@@ -364,7 +522,14 @@
 
   memset(cmd, 0, sizeof(cmd));
 
-  avr_set_bits(p->op[AVR_OP_CHIP_ERASE], cmd);
+  if (!is_pditpi()) {
+      avr_set_bits(p->op[AVR_OP_CHIP_ERASE], cmd);
+  } else {
+      cmd[0] = ISPCMD_ISP_CONF;
+      cmd[1] = ISPCONF_CHIP_ERASE;
+      cmd[2] = 0;
+      cmd[3] = 0;
+  }
   pgm->cmd(pgm, cmd, res);
   usleep(p->chip_erase_delay);
   pgm->initialize(pgm, p);
@@ -372,6 +537,188 @@
   return 0;
 }
 
+static int usbasp_read_sig_bytes(PROGRAMMER * pgm, AVRPART * p, AVRMEM *m)
+{
+  int i;
+  unsigned char cmd[4];
+  unsigned char res[4];
+
+  for (i=0; i<3; i++) {
+      memset(cmd, 0, sizeof(cmd));
+
+      cmd[0] = ISPCMD_READ_SIGNATURE;
+      cmd[1] = 0;
+      cmd[2] = i;
+      cmd[3] = 0;
+      pgm->cmd(pgm, cmd, res);
+      m->buf[i] = res[3];
+  }
+#if 0 //def XXX
+if (is_pdi()) {
+  fprintf(stderr, "ISPCMD_READ_SIGNATURE: %02x %02x %02x\n",m->buf[0],m->buf[1],m->buf[2]);
+}
+#endif
+
+  return 0;
+}
+
+static int usbasp_read_byte(PROGRAMMER * pgm, AVRPART * p, AVRMEM * m,
+                              unsigned long addr, unsigned char * value)
+{
+    int n;
+    int function;
+    unsigned char buffer[4];
+    unsigned char cmd[4];
+
+    if (!is_pditpi()) {
+        return avr_read_byte_default(pgm, p, m, addr, value);
+    }
+    function = USBASP_FUNC_READFLASH;
+    addr += m->offset;
+    if (prot_type == USBASP_V2_TPI) {
+        if (strcmp(m->desc, "flash") == 0) {
+        } else if (strcmp(m->desc, "signature") == 0) {
+        } else if (strcmp(m->desc, "fuse") == 0) {
+        } else if (strcmp(m->desc, "calibration") == 0) {
+        } else if (strcmp(m->desc, "lockbits") == 0) {
+        } else {
+            return -2;
+        }
+    } else if (prot_type == USBASP_V2_PDI) {
+        if (strcmp(m->desc, "eeprom") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_EEPROM);
+        } else if (strcmp(m->desc, "boot") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_BOOT);
+        } else if (strcmp(m->desc, "application") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_APP);
+        } else if (strcmp(m->desc, "apptable") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_APP);
+        } else if (strcmp(m->desc, "flash") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_FLASH);
+        } else if (strcmp(m->desc, "prodsig") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_FLASH);
+        } else if (strcmp(m->desc, "usersig") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_USERSIG);
+        } else if (strcmp(m->desc, "signature") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_FLASH);
+	} else if (strncmp(m->desc, "fuse", 4) == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_FUSE);
+        } else if (strcmp(m->desc, "lock") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_LOCK);
+        } else if (strcmp(m->desc, "calibration") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_CALIB);
+        } else {
+            return -2;
+        }
+    } else {
+	return -2;
+    }
+    /* set address */
+    usbasp_set_longaddr(pgm, p, addr);
+
+    /* send command with address */
+    cmd[0] = addr & 0xFF;
+    cmd[1] = addr >> 8;
+    cmd[2] = 0;
+    cmd[3] = 0;
+    n = usbasp_transmit(pgm, 1, function, cmd, buffer, 1);
+
+    if (n != 1) {
+      fprintf(stderr, "%s: error: wrong reading bytes %x\n",
+	      progname, n);
+      exit(1);
+    }
+    *value = buffer[0];
+    return 0;
+}
+
+static int usbasp_write_byte(PROGRAMMER * pgm, AVRPART * p, AVRMEM * m,
+                               unsigned long addr, unsigned char data)
+{
+    int blocksize = 1;
+    int n;
+    int function;
+    unsigned char buffer[4];
+    unsigned char cmd[4];
+
+    if (!is_pditpi()) {
+        return avr_write_byte_default(pgm, p, m, addr, data);
+    }
+    memset(buffer,0, sizeof(buffer));
+    buffer[0] = data;
+    function = USBASP_FUNC_WRITEFLASH;
+    addr += m->offset;
+    if (prot_type == USBASP_V2_TPI) {
+        int sect_erase = 0;
+        if (strcmp(m->desc, "flash") == 0) {
+		sect_erase = 1;
+		blocksize = 0;
+        } else if (strcmp(m->desc, "fuse") == 0) {
+		sect_erase = 1;
+		blocksize = 2;
+        } else if (strcmp(m->desc, "lockbits") == 0) {
+		blocksize = 2;
+        } else {
+            return -2;
+        }
+	if (sect_erase) {
+	    usbasp_write_cs(pgm, p, TPI_NVMCMD, TPI_NVM_SECT_ERASE);
+
+	    cmd[0] = (addr & 0xFF) | 0x01;
+	    cmd[1] = addr >> 8;
+	    cmd[2] = 0;
+	    cmd[3] = USBASP_BLOCKFLAG_FIRST|USBASP_BLOCKFLAG_LAST;
+
+	    n = usbasp_transmit(pgm, 0, function, cmd, buffer, 1);
+	    if (n != 1) {
+	      fprintf(stderr, "%s: error: wrong count at writing %x\n",
+		      progname, n);
+	      exit(1);
+	    }
+	    //usbasp_chk_busy(pgm, p);
+	}
+	if (blocksize == 0) {
+	    //usbasp_write_cs(pgm, p, TPI_NVMCMD, TPI_NVM_NOP);
+	    return 0;
+	}
+	usbasp_write_cs(pgm, p, TPI_NVMCMD, TPI_NVM_WRITE);
+    } else if (prot_type == USBASP_V2_PDI) {
+        if (strncmp(m->desc, "fuse", 4) == 0) {
+		usbasp_write_cs(pgm, p, PDI_NVM_CMD, PDI_NVM_WRITE_FUSE);
+        } else if (strcmp(m->desc, "lock") == 0) {
+		usbasp_write_cs(pgm, p, PDI_NVM_CMD, PDI_NVM_WRITE_LOCKBIT);
+        } else if (strcmp(m->desc, "usersig") == 0) {
+		usbasp_write_cs(pgm, p, PDI_NVM_CMD, PDI_NVM_ERASE_USERSIG);
+        } else if (strcmp(m->desc, "boot") == 0) {
+		usbasp_write_cs(pgm, p, PDI_NVM_CMD, PDI_NVM_ERASE_BOOT);
+        } else if (strcmp(m->desc, "application") == 0) {
+		usbasp_write_cs(pgm, p, PDI_NVM_CMD, PDI_NVM_ERASE_APP);
+        } else if (strcmp(m->desc, "eeprom") == 0) {
+		usbasp_write_cs(pgm, p, PDI_NVM_CMD, PDI_NVM_ERASE_EEPROM);
+        } else {
+            return -2;
+        }
+	blocksize = 1;
+    } else {
+	return -2;
+    }
+    /* set address */
+    usbasp_set_longaddr(pgm, p, addr);
+
+    cmd[0] = addr & 0xFF;
+    cmd[1] = addr >> 8;
+    cmd[2] = 0;
+    cmd[3] = USBASP_BLOCKFLAG_FIRST|USBASP_BLOCKFLAG_LAST;
+
+    n = usbasp_transmit(pgm, 0, function, cmd, buffer, blocksize);
+    if (n != blocksize) {
+      fprintf(stderr, "%s: error: wrong count at writing %x\n",
+	      progname, n);
+      exit(1);
+    }
+    //usbasp_chk_busy(pgm, p);
+    return 0;
+}
 
 static int usbasp_paged_load(PROGRAMMER * pgm, AVRPART * p, AVRMEM * m,
                              int page_size, int n_bytes)
@@ -382,14 +729,42 @@
   int wbytes = n_bytes;
   int blocksize;
   unsigned char * buffer = m->buf;
-  int function;
+  int function = USBASP_FUNC_READFLASH;
 
-  if (strcmp(m->desc, "flash") == 0) {
-    function = USBASP_FUNC_READFLASH;
-  } else if (strcmp(m->desc, "eeprom") == 0) {
-    function = USBASP_FUNC_READEEPROM;
-  } else {
-    return -2;
+  if (!is_pditpi()) {
+      if (strcmp(m->desc, "flash") == 0) {
+        function = USBASP_FUNC_READFLASH;
+      } else if (strcmp(m->desc, "eeprom") == 0) {
+        function = USBASP_FUNC_READEEPROM;
+      } else {
+        return -2;
+      }
+   } else if (prot_type == USBASP_V2_TPI) {
+	address += m->offset;
+        if (strcmp(m->desc, "flash") == 0) {
+        } else {
+            return -2;
+        }
+	usbasp_write_cs(pgm, p, TPI_NVMCMD, TPI_NVM_WRITE);
+   } else if (prot_type == USBASP_V2_PDI) {
+	address += m->offset;
+        if (strcmp(m->desc, "eeprom") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_EEPROM);
+        } else if (strcmp(m->desc, "boot") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_BOOT);
+        } else if (strcmp(m->desc, "application") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_APP);
+        } else if (strcmp(m->desc, "apptable") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_APP);
+        } else if (strcmp(m->desc, "flash") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_FLASH);
+        } else if (strcmp(m->desc, "prodsig") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_FLASH);
+        } else if (strcmp(m->desc, "usersig") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_USERSIG);
+        } else {
+            return -2;
+        }
   }
 
   /* set blocksize depending on sck frequency */  
@@ -405,14 +780,8 @@
     }
     wbytes -= blocksize;
 
-    /* set address (new mode) - if firmware on usbasp support newmode, then they use address from this command */
-    unsigned char temp[4];
-    memset(temp, 0, sizeof(temp));
-    cmd[0] = address & 0xFF;
-    cmd[1] = address >> 8;
-    cmd[2] = address >> 16;
-    cmd[3] = address >> 24;
-    usbasp_transmit(pgm, 1, USBASP_FUNC_SETLONGADDRESS, cmd, temp, sizeof(temp));
+    /* set address */
+    usbasp_set_longaddr(pgm, p, address);
 
     /* send command with address (compatibility mode) - if firmware on
 	  usbasp doesn't support newmode, then they use address from this */
@@ -449,15 +818,46 @@
   int blocksize;
   unsigned char * buffer = m->buf;
   unsigned char blockflags = USBASP_BLOCKFLAG_FIRST;
-  int function;
+  int function = USBASP_FUNC_WRITEFLASH;;
 
-  if (strcmp(m->desc, "flash") == 0) {
-    function = USBASP_FUNC_WRITEFLASH;
-  } else if (strcmp(m->desc, "eeprom") == 0) {
-    function = USBASP_FUNC_WRITEEEPROM;
-  } else {
-    return -2;
-  }
+  if (!is_pditpi()) {
+      if (strcmp(m->desc, "flash") == 0) {
+        function = USBASP_FUNC_WRITEFLASH;
+      } else if (strcmp(m->desc, "eeprom") == 0) {
+        function = USBASP_FUNC_WRITEEEPROM;
+      } else {
+        return -2;
+      }
+   } else if (prot_type == USBASP_V2_TPI) {
+	address += m->offset;
+        if (strcmp(m->desc, "flash") == 0) {
+        } else {
+            return -2;
+        }
+	usbasp_write_byte(pgm, p, m, 0 , 0xff); // ERASE
+	usbasp_write_cs(pgm, p, TPI_NVMCMD, TPI_NVM_WRITE);
+   } else if (prot_type == USBASP_V2_PDI) {
+	address += m->offset;
+        if (strcmp(m->desc, "eeprom") == 0) {
+	     //usbasp_write_byte(pgm, p, m, 0 , 0xff); // ERASE
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_EEPROM);
+        } else if (strcmp(m->desc, "boot") == 0) {
+	     usbasp_write_byte(pgm, p, m, 0 , 0xff); // ERASE
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_BOOT);
+        } else if (strcmp(m->desc, "application") == 0) {
+	     usbasp_write_byte(pgm, p, m, 0 , 0xff); // ERASE
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_APP);
+        } else if (strcmp(m->desc, "apptable") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_APP);
+        } else if (strcmp(m->desc, "usersig") == 0) {
+	     usbasp_write_byte(pgm, p, m, 0 , 0xff); // ERASE
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_USERSIG);
+        } else if (strcmp(m->desc, "flash") == 0) {
+             usbasp_pdi_select(pgm, p, ISPCONF_SPACE_FLASH);
+        } else {
+            return -2;
+        }
+   }
 
   /* set blocksize depending on sck frequency */  
   if ((PDATA(pgm)->sckfreq_hz > 0) && (PDATA(pgm)->sckfreq_hz < 10000)) {
@@ -475,15 +875,8 @@
     wbytes -= blocksize;
 
 
-    /* set address (new mode) - if firmware on usbasp support newmode, then
-      they use address from this command */
-    unsigned char temp[4];
-    memset(temp, 0, sizeof(temp));
-    cmd[0] = address & 0xFF;
-    cmd[1] = address >> 8;
-    cmd[2] = address >> 16;
-    cmd[3] = address >> 24;
-    usbasp_transmit(pgm, 1, USBASP_FUNC_SETLONGADDRESS, cmd, temp, sizeof(temp));
+    /* set address */
+    usbasp_set_longaddr(pgm, p, address);
 
     /* normal command - firmware what support newmode - use address from previous command,
       firmware what doesn't support newmode - ignore previous command and use address from this command */
@@ -529,6 +922,23 @@
   { USBASP_ISP_SCK_0_5, 500 }
 };
 
+static struct sckoptions_t usbaspSCKoptions2[] = {
+  { USBASP_ISP_SCK_8000, 8000000 },
+  { USBASP_ISP_SCK_4000, 4000000 },
+  { USBASP_ISP_SCK_2000, 2000000 },
+  { USBASP_ISP_SCK_1000, 1000000 },
+  { USBASP_ISP_SCK_500,   500000 },
+  { USBASP_ISP_SCK_250,   250000 },
+  { USBASP_ISP_SCK_125,   125000 },
+  { USBASP_ISP_SCK_62_5,   62500 },
+  { USBASP_ISP_SCK_32,     32000 },
+  { USBASP_ISP_SCK_16,     16000 },
+  { USBASP_ISP_SCK_8,       8000 },
+  { USBASP_ISP_SCK_4,       4000 },
+  { USBASP_ISP_SCK_2,       2000 },
+  { USBASP_ISP_SCK_1,       1000 },
+  { USBASP_ISP_SCK_0_5,      500 }
+};
 
 /*
  * Set sck period (in seconds)
@@ -537,12 +947,21 @@
 static int usbasp_set_sck_period(PROGRAMMER *pgm, double sckperiod)
 {
   char clockoption = USBASP_ISP_SCK_AUTO;
+  struct sckoptions_t *sckopt;
+  int sckopt_len;
   unsigned char res[4];
   unsigned char cmd[4];
 
   memset(cmd, 0, sizeof(cmd));
   memset(res, 0, sizeof(res));
 
+  if (prot_ver == USBASP_PROT_V2) {
+  	sckopt = usbaspSCKoptions2;
+  	sckopt_len = sizeof(usbaspSCKoptions2)/sizeof(usbaspSCKoptions2[0]);
+  } else {
+  	sckopt = usbaspSCKoptions;
+  	sckopt_len = sizeof(usbaspSCKoptions)/sizeof(usbaspSCKoptions[0]);
+  }
   /* reset global sck frequency to auto */
   PDATA(pgm)->sckfreq_hz = 0;
 
@@ -560,17 +979,17 @@
     if (verbose >= 2)
       fprintf(stderr, "%s: try to set SCK period to %g s (= %i Hz)\n", progname, sckperiod, sckfreq);
 
-    if (sckfreq >= usbaspSCKoptions[0].frequency) {
-      clockoption = usbaspSCKoptions[0].id;
-      usefreq = usbaspSCKoptions[0].frequency;
+    if (sckfreq >= sckopt[0].frequency) {
+      clockoption = sckopt[0].id;
+      usefreq = sckopt[0].frequency;
     } else {
 
       /* find clock option next to given clock */
       int i;
-      for (i = 0; i < sizeof(usbaspSCKoptions) / sizeof(usbaspSCKoptions[0]); i++) {
-        if (sckfreq >= usbaspSCKoptions[i].frequency - 1) { /* subtract 1 to compensate round errors */
-          clockoption = usbaspSCKoptions[i].id;
-          usefreq = usbaspSCKoptions[i].frequency;
+      for (i = 0; i < sckopt_len; i++) {
+        if (sckfreq >= sckopt[i].frequency - 1) { /* subtract 1 to compensate round errors */
+          clockoption = sckopt[i].id;
+          usefreq = sckopt[i].frequency;
           break;
         }
       }
@@ -614,10 +1033,11 @@
   pgm->cmd            = usbasp_cmd;
   pgm->open           = usbasp_open;
   pgm->close          = usbasp_close;
-  pgm->read_byte      = avr_read_byte_default;
-  pgm->write_byte     = avr_write_byte_default;
+  pgm->read_byte      = usbasp_read_byte;
+  pgm->write_byte     = usbasp_write_byte;
   pgm->parseexitspecs = usbasp_parseexitspecs;
 
+  pgm->read_sig_bytes = usbasp_read_sig_bytes;
   /*
    * optional functions
    */
diff -ru avrdude-5.10-org/usbasp.h avrdude-5.10/usbasp.h
--- avrdude-5.10-org/usbasp.h	2010-12-21 08:20:08.000000000 +0900
+++ avrdude-5.10/usbasp.h	2011-01-04 09:45:10.000000000 +0900
@@ -31,6 +31,13 @@
 #define	USBASP_OLD_VID      0x03EB  /* ATMEL */
 #define	USBASP_OLD_PID	    0xC7B4  /* (unoffical) USBasp */
 
+
+/* USBasp v2 defines */
+#define USBASP_PROT_V2	2
+#define USBASP_V2_ISP2	1
+#define USBASP_V2_TPI	2
+#define USBASP_V2_PDI	3
+
 /* USB function call identifiers */
 #define USBASP_FUNC_CONNECT    1
 #define USBASP_FUNC_DISCONNECT 2
@@ -66,6 +73,16 @@
 #define USBASP_ISP_SCK_750    11  /* 750 kHz   */
 #define USBASP_ISP_SCK_1500   12  /* 1.5 MHz   */
 
+/* (v2 Protocol modefied) */
+#define USBASP_ISP_SCK_62_5    8   /*  62.5 kHz */
+#define USBASP_ISP_SCK_125     9   /* 125  kHz */
+#define USBASP_ISP_SCK_250    10  /* 250 kHz   */
+#define USBASP_ISP_SCK_500    11  /* 500 kHz   */
+#define USBASP_ISP_SCK_1000   12  /* 1.0 MHz   */
+#define USBASP_ISP_SCK_2000   13  /* 2.0 MHz   */
+#define USBASP_ISP_SCK_4000   14  /* 4.0 MHz   */
+#define USBASP_ISP_SCK_8000   15  /* 8.0 MHz   */
+
 typedef struct sckoptions_t {
   int id;
   double frequency;
@@ -82,8 +99,71 @@
 
 void usbasp_initpgm (PROGRAMMER * pgm);
 
+/* USBasp v2 cmd set */
+#define ISPCMD_ISP_CONF             0xac
+  #define ISPCONF_CHIP_ERASE        0x80
+  #define ISPCONF_RESET             0x59 /* PDI */
+  #define ISPCONF_SET_SPACE         0x01 /* PDI */
+
+#define ISPCONF_SPACE_FLASH		0
+#define ISPCONF_SPACE_APP		1
+#define ISPCONF_SPACE_BOOT		2
+#define ISPCONF_SPACE_EEPROM		3
+#define ISPCONF_SPACE_FUSE		4
+#define ISPCONF_SPACE_LOCK		5
+#define ISPCONF_SPACE_USERSIG		6
+#define ISPCONF_SPACE_CALIB		7
+
+#define ISPCMD_READ_SIGNATURE       0x30
+#define ISPCMD_READ_EEPROM          0xa0
+#define ISPCMD_WRITE_EEPROM         0xc0
+#define ISPCMD_CHK_BUSY             0xf0
+
+#define TPI_NVMCMD              0x33
+  #define TPI_NVM_NOP           0x00
+  #define TPI_NVM_CHIP_ERASE    0x10
+  #define TPI_NVM_SECT_ERASE    0x14
+  #define TPI_NVM_WRITE         0x1d
+
+#define PDI_NVM_BASE            0x01c0
+#define PDI_NVM_CMD             (PDI_NVM_BASE + 0xa )
+  #define PDI_NVM_NOP                     0x00
+  #define PDI_NVM_READ_NVM                0x43
+  #define PDI_NVM_WRITE_FUSE              0x4C
+  #define PDI_NVM_WRITE_LOCKBIT           0x08
+
+  #define PDI_NVM_ERASE_EEPROM            0x30  // need dmy write
+  #define PDI_NVM_ERASE_APP               0x20  // need dmy write
+  #define PDI_NVM_ERASE_BOOT              0x68  // need dmy write
+  #define PDI_NVM_ERASE_USERSIG           0x18  // need dmy write
+
+/* for debug */
+
+/* tpiReadCS/tpiWriteCS addressing
+ *
+ * SLDCS/SSTCS : addr | 0x8000
+ * SIN/SOUT    : addr 
+ */
+#define TPI_CS_TPISR            0x8000  // in CSS offset 0
+  #define TPI_CS_NVMEN          1
+#define TPI_NVMCSR              0x32
+  #define TPI_NVMBSY              7
+
+/* pdiReadCS/pdiWriteCS addressing
+ *
+ * LDCS/STCS : addr | 0x8000
+ * LDS/STS   : addr - 0x01000000
+ */
+#define PDI_CS_STATUS           0x8000
+  #define PDI_CS_NVMEN          1
+#define PDI_CS_RESET            0x8001
+  #define PDI_CS_RESET_KEY              0x59
+  #define PDI_CS_RESET_NONE             0x00
+#define PDI_CS_CTRL             0x8002
+
 #ifdef __cplusplus
 }
 #endif
 
+
 #endif /* usbasp_h */
